// Code generated by github.com/efritz/go-mockgen 0.1.0; DO NOT EDIT.

package worker

import (
	"context"
	gitserver "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/gitserver"
	dbstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/stores/dbstore"
	lsifstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/stores/lsifstore"
	basestore "github.com/sourcegraph/sourcegraph/internal/db/basestore"
	"sync"
	"time"
)

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockDBStore struct {
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *DBStoreDeleteOverlappingDumpsFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *DBStoreDoneFunc
	// GetDumpForCommitFunc is an instance of a mock function object
	// controlling the behavior of the method GetDumpForCommit.
	GetDumpForCommitFunc *DBStoreGetDumpForCommitFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *DBStoreHandleFunc
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *DBStoreMarkCompleteFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *DBStoreMarkRepositoryAsDirtyFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *DBStoreRepoNameFunc
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *DBStoreRequeueFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *DBStoreTransactFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *DBStoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *DBStoreUpdatePackagesFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *DBStoreWithFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				return nil
			},
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		GetDumpForCommitFunc: &DBStoreGetDumpForCommitFunc{
			defaultHook: func(context.Context, int, string, string, string) (dbstore.Dump, bool, error) {
				return dbstore.Dump{}, false, nil
			},
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: func() *basestore.TransactableHandle {
				return nil
			},
		},
		MarkCompleteFunc: &DBStoreMarkCompleteFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				return "", nil
			},
		},
		RequeueFunc: &DBStoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: func(context.Context) (DBStore, error) {
				return nil, nil
			},
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, []lsifstore.PackageReference) error {
				return nil
			},
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: func(context.Context, []lsifstore.Package) error {
				return nil
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) DBStore {
				return nil
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: i.Done,
		},
		GetDumpForCommitFunc: &DBStoreGetDumpForCommitFunc{
			defaultHook: i.GetDumpForCommit,
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: i.Handle,
		},
		MarkCompleteFunc: &DBStoreMarkCompleteFunc{
			defaultHook: i.MarkComplete,
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RequeueFunc: &DBStoreRequeueFunc{
			defaultHook: i.Requeue,
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// DBStoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked.
type DBStoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []DBStoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(DBStoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *DBStoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteOverlappingDumpsFunc) appendCall(r0 DBStoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteOverlappingDumpsFuncCall
// objects describing the invocations of this function.
func (f *DBStoreDeleteOverlappingDumpsFunc) History() []DBStoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of
// MockDBStore.
type DBStoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreDoneFunc describes the behavior when the Done method of the parent
// MockDBStore instance is invoked.
type DBStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []DBStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(DBStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *DBStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDoneFunc) appendCall(r0 DBStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDoneFuncCall objects describing the
// invocations of this function.
func (f *DBStoreDoneFunc) History() []DBStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockDBStore.
type DBStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreGetDumpForCommitFunc describes the behavior when the
// GetDumpForCommit method of the parent MockDBStore instance is invoked.
type DBStoreGetDumpForCommitFunc struct {
	defaultHook func(context.Context, int, string, string, string) (dbstore.Dump, bool, error)
	hooks       []func(context.Context, int, string, string, string) (dbstore.Dump, bool, error)
	history     []DBStoreGetDumpForCommitFuncCall
	mutex       sync.Mutex
}

// GetDumpForCommit delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) GetDumpForCommit(v0 context.Context, v1 int, v2 string, v3 string, v4 string) (dbstore.Dump, bool, error) {
	r0, r1, r2 := m.GetDumpForCommitFunc.nextHook()(v0, v1, v2, v3, v4)
	m.GetDumpForCommitFunc.appendCall(DBStoreGetDumpForCommitFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetDumpForCommit
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreGetDumpForCommitFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) (dbstore.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpForCommit method of the parent MockDBStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreGetDumpForCommitFunc) PushHook(hook func(context.Context, int, string, string, string) (dbstore.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetDumpForCommitFunc) SetDefaultReturn(r0 dbstore.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) (dbstore.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetDumpForCommitFunc) PushReturn(r0 dbstore.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, string, string, string) (dbstore.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetDumpForCommitFunc) nextHook() func(context.Context, int, string, string, string) (dbstore.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetDumpForCommitFunc) appendCall(r0 DBStoreGetDumpForCommitFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetDumpForCommitFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetDumpForCommitFunc) History() []DBStoreGetDumpForCommitFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetDumpForCommitFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetDumpForCommitFuncCall is an object that describes an invocation
// of method GetDumpForCommit on an instance of MockDBStore.
type DBStoreGetDumpForCommitFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetDumpForCommitFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetDumpForCommitFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreHandleFunc describes the behavior when the Handle method of the
// parent MockDBStore instance is invoked.
type DBStoreHandleFunc struct {
	defaultHook func() *basestore.TransactableHandle
	hooks       []func() *basestore.TransactableHandle
	history     []DBStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Handle() *basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(DBStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreHandleFunc) SetDefaultHook(hook func() *basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreHandleFunc) PushHook(hook func() *basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreHandleFunc) SetDefaultReturn(r0 *basestore.TransactableHandle) {
	f.SetDefaultHook(func() *basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreHandleFunc) PushReturn(r0 *basestore.TransactableHandle) {
	f.PushHook(func() *basestore.TransactableHandle {
		return r0
	})
}

func (f *DBStoreHandleFunc) nextHook() func() *basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHandleFunc) appendCall(r0 DBStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHandleFuncCall objects describing
// the invocations of this function.
func (f *DBStoreHandleFunc) History() []DBStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHandleFuncCall is an object that describes an invocation of method
// Handle on an instance of MockDBStore.
type DBStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreMarkCompleteFunc describes the behavior when the MarkComplete
// method of the parent MockDBStore instance is invoked.
type DBStoreMarkCompleteFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkCompleteFuncCall
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) MarkComplete(v0 context.Context, v1 int) error {
	r0 := m.MarkCompleteFunc.nextHook()(v0, v1)
	m.MarkCompleteFunc.appendCall(DBStoreMarkCompleteFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreMarkCompleteFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreMarkCompleteFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreMarkCompleteFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreMarkCompleteFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkCompleteFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkCompleteFunc) appendCall(r0 DBStoreMarkCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *DBStoreMarkCompleteFunc) History() []DBStoreMarkCompleteFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkCompleteFuncCall is an object that describes an invocation of
// method MarkComplete on an instance of MockDBStore.
type DBStoreMarkCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked.
type DBStoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(DBStoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) appendCall(r0 DBStoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkRepositoryAsDirtyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreMarkRepositoryAsDirtyFunc) History() []DBStoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockDBStore.
type DBStoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreRepoNameFunc describes the behavior when the RepoName method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []DBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(DBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNameFunc) appendCall(r0 DBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNameFunc) History() []DBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNameFuncCall is an object that describes an invocation of
// method RepoName on an instance of MockDBStore.
type DBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreRequeueFunc describes the behavior when the Requeue method of the
// parent MockDBStore instance is invoked.
type DBStoreRequeueFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []DBStoreRequeueFuncCall
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(DBStoreRequeueFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRequeueFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreRequeueFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreRequeueFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreRequeueFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *DBStoreRequeueFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRequeueFunc) appendCall(r0 DBStoreRequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRequeueFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRequeueFunc) History() []DBStoreRequeueFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRequeueFuncCall is an object that describes an invocation of
// method Requeue on an instance of MockDBStore.
type DBStoreRequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreTransactFunc describes the behavior when the Transact method of
// the parent MockDBStore instance is invoked.
type DBStoreTransactFunc struct {
	defaultHook func(context.Context) (DBStore, error)
	hooks       []func(context.Context) (DBStore, error)
	history     []DBStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Transact(v0 context.Context) (DBStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(DBStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreTransactFunc) SetDefaultHook(hook func(context.Context) (DBStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreTransactFunc) PushHook(hook func(context.Context) (DBStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreTransactFunc) SetDefaultReturn(r0 DBStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreTransactFunc) PushReturn(r0 DBStore, r1 error) {
	f.PushHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

func (f *DBStoreTransactFunc) nextHook() func(context.Context) (DBStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreTransactFunc) appendCall(r0 DBStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreTransactFuncCall objects describing
// the invocations of this function.
func (f *DBStoreTransactFunc) History() []DBStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockDBStore.
type DBStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked.
type DBStoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, []lsifstore.PackageReference) error
	hooks       []func(context.Context, []lsifstore.PackageReference) error
	history     []DBStoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackageReferences(v0 context.Context, v1 []lsifstore.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1)
	m.UpdatePackageReferencesFunc.appendCall(DBStoreUpdatePackageReferencesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, []lsifstore.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, []lsifstore.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []lsifstore.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []lsifstore.PackageReference) error {
		return r0
	})
}

func (f *DBStoreUpdatePackageReferencesFunc) nextHook() func(context.Context, []lsifstore.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackageReferencesFunc) appendCall(r0 DBStoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *DBStoreUpdatePackageReferencesFunc) History() []DBStoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of
// MockDBStore.
type DBStoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []lsifstore.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockDBStore instance is invoked.
type DBStoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, []lsifstore.Package) error
	hooks       []func(context.Context, []lsifstore.Package) error
	history     []DBStoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackages(v0 context.Context, v1 []lsifstore.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1)
	m.UpdatePackagesFunc.appendCall(DBStoreUpdatePackagesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, []lsifstore.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreUpdatePackagesFunc) PushHook(hook func(context.Context, []lsifstore.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []lsifstore.Package) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []lsifstore.Package) error {
		return r0
	})
}

func (f *DBStoreUpdatePackagesFunc) nextHook() func(context.Context, []lsifstore.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackagesFunc) appendCall(r0 DBStoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdatePackagesFunc) History() []DBStoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackagesFuncCall is an object that describes an invocation
// of method UpdatePackages on an instance of MockDBStore.
type DBStoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []lsifstore.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreWithFunc describes the behavior when the With method of the parent
// MockDBStore instance is invoked.
type DBStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) DBStore
	hooks       []func(basestore.ShareableStore) DBStore
	history     []DBStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) With(v0 basestore.ShareableStore) DBStore {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(DBStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) DBStore) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreWithFunc) PushHook(hook func(basestore.ShareableStore) DBStore) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreWithFunc) SetDefaultReturn(r0 DBStore) {
	f.SetDefaultHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreWithFunc) PushReturn(r0 DBStore) {
	f.PushHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

func (f *DBStoreWithFunc) nextHook() func(basestore.ShareableStore) DBStore {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreWithFunc) appendCall(r0 DBStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreWithFuncCall objects describing the
// invocations of this function.
func (f *DBStoreWithFunc) History() []DBStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreWithFuncCall is an object that describes an invocation of method
// With on an instance of MockDBStore.
type DBStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockGitserverClient struct {
	// DiffFileStatusFunc is an instance of a mock function object
	// controlling the behavior of the method DiffFileStatus.
	DiffFileStatusFunc *GitserverClientDiffFileStatusFunc
	// DirectoryChildrenFunc is an instance of a mock function object
	// controlling the behavior of the method DirectoryChildren.
	DirectoryChildrenFunc *GitserverClientDirectoryChildrenFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		DiffFileStatusFunc: &GitserverClientDiffFileStatusFunc{
			defaultHook: func(context.Context, int, string, string) (map[string]gitserver.Status, error) {
				return nil, nil
			},
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, int, string, []string) (map[string][]string, error) {
				return nil, nil
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		DiffFileStatusFunc: &GitserverClientDiffFileStatusFunc{
			defaultHook: i.DiffFileStatus,
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: i.DirectoryChildren,
		},
	}
}

// GitserverClientDiffFileStatusFunc describes the behavior when the
// DiffFileStatus method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientDiffFileStatusFunc struct {
	defaultHook func(context.Context, int, string, string) (map[string]gitserver.Status, error)
	hooks       []func(context.Context, int, string, string) (map[string]gitserver.Status, error)
	history     []GitserverClientDiffFileStatusFuncCall
	mutex       sync.Mutex
}

// DiffFileStatus delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DiffFileStatus(v0 context.Context, v1 int, v2 string, v3 string) (map[string]gitserver.Status, error) {
	r0, r1 := m.DiffFileStatusFunc.nextHook()(v0, v1, v2, v3)
	m.DiffFileStatusFunc.appendCall(GitserverClientDiffFileStatusFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DiffFileStatus
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientDiffFileStatusFunc) SetDefaultHook(hook func(context.Context, int, string, string) (map[string]gitserver.Status, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DiffFileStatus method of the parent MockGitserverClient instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientDiffFileStatusFunc) PushHook(hook func(context.Context, int, string, string) (map[string]gitserver.Status, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientDiffFileStatusFunc) SetDefaultReturn(r0 map[string]gitserver.Status, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (map[string]gitserver.Status, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientDiffFileStatusFunc) PushReturn(r0 map[string]gitserver.Status, r1 error) {
	f.PushHook(func(context.Context, int, string, string) (map[string]gitserver.Status, error) {
		return r0, r1
	})
}

func (f *GitserverClientDiffFileStatusFunc) nextHook() func(context.Context, int, string, string) (map[string]gitserver.Status, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDiffFileStatusFunc) appendCall(r0 GitserverClientDiffFileStatusFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientDiffFileStatusFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientDiffFileStatusFunc) History() []GitserverClientDiffFileStatusFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDiffFileStatusFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDiffFileStatusFuncCall is an object that describes an
// invocation of method DiffFileStatus on an instance of
// MockGitserverClient.
type GitserverClientDiffFileStatusFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string]gitserver.Status
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDiffFileStatusFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDiffFileStatusFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientDirectoryChildrenFunc describes the behavior when the
// DirectoryChildren method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientDirectoryChildrenFunc struct {
	defaultHook func(context.Context, int, string, []string) (map[string][]string, error)
	hooks       []func(context.Context, int, string, []string) (map[string][]string, error)
	history     []GitserverClientDirectoryChildrenFuncCall
	mutex       sync.Mutex
}

// DirectoryChildren delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DirectoryChildren(v0 context.Context, v1 int, v2 string, v3 []string) (map[string][]string, error) {
	r0, r1 := m.DirectoryChildrenFunc.nextHook()(v0, v1, v2, v3)
	m.DirectoryChildrenFunc.appendCall(GitserverClientDirectoryChildrenFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirectoryChildren
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirectoryChildren method of the parent MockGitserverClient instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDirectoryChildrenFunc) PushHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultReturn(r0 map[string][]string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientDirectoryChildrenFunc) PushReturn(r0 map[string][]string, r1 error) {
	f.PushHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientDirectoryChildrenFunc) nextHook() func(context.Context, int, string, []string) (map[string][]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDirectoryChildrenFunc) appendCall(r0 GitserverClientDirectoryChildrenFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientDirectoryChildrenFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientDirectoryChildrenFunc) History() []GitserverClientDirectoryChildrenFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDirectoryChildrenFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDirectoryChildrenFuncCall is an object that describes an
// invocation of method DirectoryChildren on an instance of
// MockGitserverClient.
type GitserverClientDirectoryChildrenFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockLSIFStore is a mock implementation of the LSIFStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockLSIFStore struct {
	// DocumentsReferencingFunc is an instance of a mock function object
	// controlling the behavior of the method DocumentsReferencing.
	DocumentsReferencingFunc *LSIFStoreDocumentsReferencingFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *LSIFStoreDoneFunc
	// PathsWithPrefixFunc is an instance of a mock function object
	// controlling the behavior of the method PathsWithPrefix.
	PathsWithPrefixFunc *LSIFStorePathsWithPrefixFunc
	// ReadDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method ReadDefinitions.
	ReadDefinitionsFunc *LSIFStoreReadDefinitionsFunc
	// ReadDocumentFunc is an instance of a mock function object controlling
	// the behavior of the method ReadDocument.
	ReadDocumentFunc *LSIFStoreReadDocumentFunc
	// ReadMetaFunc is an instance of a mock function object controlling the
	// behavior of the method ReadMeta.
	ReadMetaFunc *LSIFStoreReadMetaFunc
	// ReadReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method ReadReferences.
	ReadReferencesFunc *LSIFStoreReadReferencesFunc
	// ReadResultChunkFunc is an instance of a mock function object
	// controlling the behavior of the method ReadResultChunk.
	ReadResultChunkFunc *LSIFStoreReadResultChunkFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *LSIFStoreTransactFunc
	// WriteDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDefinitions.
	WriteDefinitionsFunc *LSIFStoreWriteDefinitionsFunc
	// WriteDocumentsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDocuments.
	WriteDocumentsFunc *LSIFStoreWriteDocumentsFunc
	// WriteMetaFunc is an instance of a mock function object controlling
	// the behavior of the method WriteMeta.
	WriteMetaFunc *LSIFStoreWriteMetaFunc
	// WriteReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method WriteReferences.
	WriteReferencesFunc *LSIFStoreWriteReferencesFunc
	// WriteResultChunksFunc is an instance of a mock function object
	// controlling the behavior of the method WriteResultChunks.
	WriteResultChunksFunc *LSIFStoreWriteResultChunksFunc
}

// NewMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		DocumentsReferencingFunc: &LSIFStoreDocumentsReferencingFunc{
			defaultHook: func(context.Context, int, []string) ([]string, error) {
				return nil, nil
			},
		},
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		PathsWithPrefixFunc: &LSIFStorePathsWithPrefixFunc{
			defaultHook: func(context.Context, int, string) ([]string, error) {
				return nil, nil
			},
		},
		ReadDefinitionsFunc: &LSIFStoreReadDefinitionsFunc{
			defaultHook: func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
				return nil, 0, nil
			},
		},
		ReadDocumentFunc: &LSIFStoreReadDocumentFunc{
			defaultHook: func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
				return lsifstore.DocumentData{}, false, nil
			},
		},
		ReadMetaFunc: &LSIFStoreReadMetaFunc{
			defaultHook: func(context.Context, int) (lsifstore.MetaData, error) {
				return lsifstore.MetaData{}, nil
			},
		},
		ReadReferencesFunc: &LSIFStoreReadReferencesFunc{
			defaultHook: func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
				return nil, 0, nil
			},
		},
		ReadResultChunkFunc: &LSIFStoreReadResultChunkFunc{
			defaultHook: func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
				return lsifstore.ResultChunkData{}, false, nil
			},
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: func(context.Context) (LSIFStore, error) {
				return nil, nil
			},
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: func(context.Context, int, chan lsifstore.MonikerLocations) error {
				return nil
			},
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
				return nil
			},
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: func(context.Context, int, lsifstore.MetaData) error {
				return nil
			},
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: func(context.Context, int, chan lsifstore.MonikerLocations) error {
				return nil
			},
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
				return nil
			},
		},
	}
}

// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {
	return &MockLSIFStore{
		DocumentsReferencingFunc: &LSIFStoreDocumentsReferencingFunc{
			defaultHook: i.DocumentsReferencing,
		},
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: i.Done,
		},
		PathsWithPrefixFunc: &LSIFStorePathsWithPrefixFunc{
			defaultHook: i.PathsWithPrefix,
		},
		ReadDefinitionsFunc: &LSIFStoreReadDefinitionsFunc{
			defaultHook: i.ReadDefinitions,
		},
		ReadDocumentFunc: &LSIFStoreReadDocumentFunc{
			defaultHook: i.ReadDocument,
		},
		ReadMetaFunc: &LSIFStoreReadMetaFunc{
			defaultHook: i.ReadMeta,
		},
		ReadReferencesFunc: &LSIFStoreReadReferencesFunc{
			defaultHook: i.ReadReferences,
		},
		ReadResultChunkFunc: &LSIFStoreReadResultChunkFunc{
			defaultHook: i.ReadResultChunk,
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: i.Transact,
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: i.WriteDefinitions,
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: i.WriteDocuments,
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: i.WriteMeta,
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: i.WriteReferences,
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: i.WriteResultChunks,
		},
	}
}

// LSIFStoreDocumentsReferencingFunc describes the behavior when the
// DocumentsReferencing method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreDocumentsReferencingFunc struct {
	defaultHook func(context.Context, int, []string) ([]string, error)
	hooks       []func(context.Context, int, []string) ([]string, error)
	history     []LSIFStoreDocumentsReferencingFuncCall
	mutex       sync.Mutex
}

// DocumentsReferencing delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) DocumentsReferencing(v0 context.Context, v1 int, v2 []string) ([]string, error) {
	r0, r1 := m.DocumentsReferencingFunc.nextHook()(v0, v1, v2)
	m.DocumentsReferencingFunc.appendCall(LSIFStoreDocumentsReferencingFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DocumentsReferencing
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreDocumentsReferencingFunc) SetDefaultHook(hook func(context.Context, int, []string) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DocumentsReferencing method of the parent MockLSIFStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStoreDocumentsReferencingFunc) PushHook(hook func(context.Context, int, []string) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreDocumentsReferencingFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, []string) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreDocumentsReferencingFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, []string) ([]string, error) {
		return r0, r1
	})
}

func (f *LSIFStoreDocumentsReferencingFunc) nextHook() func(context.Context, int, []string) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDocumentsReferencingFunc) appendCall(r0 LSIFStoreDocumentsReferencingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDocumentsReferencingFuncCall
// objects describing the invocations of this function.
func (f *LSIFStoreDocumentsReferencingFunc) History() []LSIFStoreDocumentsReferencingFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDocumentsReferencingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDocumentsReferencingFuncCall is an object that describes an
// invocation of method DocumentsReferencing on an instance of
// MockLSIFStore.
type LSIFStoreDocumentsReferencingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDocumentsReferencingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDocumentsReferencingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreDoneFunc describes the behavior when the Done method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []LSIFStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(LSIFStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockLSIFStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LSIFStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *LSIFStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDoneFunc) appendCall(r0 LSIFStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDoneFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreDoneFunc) History() []LSIFStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockLSIFStore.
type LSIFStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStorePathsWithPrefixFunc describes the behavior when the
// PathsWithPrefix method of the parent MockLSIFStore instance is invoked.
type LSIFStorePathsWithPrefixFunc struct {
	defaultHook func(context.Context, int, string) ([]string, error)
	hooks       []func(context.Context, int, string) ([]string, error)
	history     []LSIFStorePathsWithPrefixFuncCall
	mutex       sync.Mutex
}

// PathsWithPrefix delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) PathsWithPrefix(v0 context.Context, v1 int, v2 string) ([]string, error) {
	r0, r1 := m.PathsWithPrefixFunc.nextHook()(v0, v1, v2)
	m.PathsWithPrefixFunc.appendCall(LSIFStorePathsWithPrefixFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the PathsWithPrefix
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStorePathsWithPrefixFunc) SetDefaultHook(hook func(context.Context, int, string) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PathsWithPrefix method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStorePathsWithPrefixFunc) PushHook(hook func(context.Context, int, string) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStorePathsWithPrefixFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStorePathsWithPrefixFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string) ([]string, error) {
		return r0, r1
	})
}

func (f *LSIFStorePathsWithPrefixFunc) nextHook() func(context.Context, int, string) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStorePathsWithPrefixFunc) appendCall(r0 LSIFStorePathsWithPrefixFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStorePathsWithPrefixFuncCall objects
// describing the invocations of this function.
func (f *LSIFStorePathsWithPrefixFunc) History() []LSIFStorePathsWithPrefixFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStorePathsWithPrefixFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStorePathsWithPrefixFuncCall is an object that describes an
// invocation of method PathsWithPrefix on an instance of MockLSIFStore.
type LSIFStorePathsWithPrefixFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStorePathsWithPrefixFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStorePathsWithPrefixFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreReadDefinitionsFunc describes the behavior when the
// ReadDefinitions method of the parent MockLSIFStore instance is invoked.
type LSIFStoreReadDefinitionsFunc struct {
	defaultHook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	hooks       []func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	history     []LSIFStoreReadDefinitionsFuncCall
	mutex       sync.Mutex
}

// ReadDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) ReadDefinitions(v0 context.Context, v1 int, v2 string, v3 string, v4 int, v5 int) ([]lsifstore.LocationData, int, error) {
	r0, r1, r2 := m.ReadDefinitionsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.ReadDefinitionsFunc.appendCall(LSIFStoreReadDefinitionsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadDefinitions
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreReadDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadDefinitions method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreReadDefinitionsFunc) PushHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreReadDefinitionsFunc) SetDefaultReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreReadDefinitionsFunc) PushReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreReadDefinitionsFunc) nextHook() func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReadDefinitionsFunc) appendCall(r0 LSIFStoreReadDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReadDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReadDefinitionsFunc) History() []LSIFStoreReadDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReadDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReadDefinitionsFuncCall is an object that describes an
// invocation of method ReadDefinitions on an instance of MockLSIFStore.
type LSIFStoreReadDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.LocationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReadDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReadDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreReadDocumentFunc describes the behavior when the ReadDocument
// method of the parent MockLSIFStore instance is invoked.
type LSIFStoreReadDocumentFunc struct {
	defaultHook func(context.Context, int, string) (lsifstore.DocumentData, bool, error)
	hooks       []func(context.Context, int, string) (lsifstore.DocumentData, bool, error)
	history     []LSIFStoreReadDocumentFuncCall
	mutex       sync.Mutex
}

// ReadDocument delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) ReadDocument(v0 context.Context, v1 int, v2 string) (lsifstore.DocumentData, bool, error) {
	r0, r1, r2 := m.ReadDocumentFunc.nextHook()(v0, v1, v2)
	m.ReadDocumentFunc.appendCall(LSIFStoreReadDocumentFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadDocument method
// of the parent MockLSIFStore instance is invoked and the hook queue is
// empty.
func (f *LSIFStoreReadDocumentFunc) SetDefaultHook(hook func(context.Context, int, string) (lsifstore.DocumentData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadDocument method of the parent MockLSIFStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreReadDocumentFunc) PushHook(hook func(context.Context, int, string) (lsifstore.DocumentData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreReadDocumentFunc) SetDefaultReturn(r0 lsifstore.DocumentData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreReadDocumentFunc) PushReturn(r0 lsifstore.DocumentData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreReadDocumentFunc) nextHook() func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReadDocumentFunc) appendCall(r0 LSIFStoreReadDocumentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReadDocumentFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReadDocumentFunc) History() []LSIFStoreReadDocumentFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReadDocumentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReadDocumentFuncCall is an object that describes an invocation
// of method ReadDocument on an instance of MockLSIFStore.
type LSIFStoreReadDocumentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.DocumentData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReadDocumentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReadDocumentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreReadMetaFunc describes the behavior when the ReadMeta method of
// the parent MockLSIFStore instance is invoked.
type LSIFStoreReadMetaFunc struct {
	defaultHook func(context.Context, int) (lsifstore.MetaData, error)
	hooks       []func(context.Context, int) (lsifstore.MetaData, error)
	history     []LSIFStoreReadMetaFuncCall
	mutex       sync.Mutex
}

// ReadMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) ReadMeta(v0 context.Context, v1 int) (lsifstore.MetaData, error) {
	r0, r1 := m.ReadMetaFunc.nextHook()(v0, v1)
	m.ReadMetaFunc.appendCall(LSIFStoreReadMetaFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReadMeta method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreReadMetaFunc) SetDefaultHook(hook func(context.Context, int) (lsifstore.MetaData, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadMeta method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreReadMetaFunc) PushHook(hook func(context.Context, int) (lsifstore.MetaData, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreReadMetaFunc) SetDefaultReturn(r0 lsifstore.MetaData, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (lsifstore.MetaData, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreReadMetaFunc) PushReturn(r0 lsifstore.MetaData, r1 error) {
	f.PushHook(func(context.Context, int) (lsifstore.MetaData, error) {
		return r0, r1
	})
}

func (f *LSIFStoreReadMetaFunc) nextHook() func(context.Context, int) (lsifstore.MetaData, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReadMetaFunc) appendCall(r0 LSIFStoreReadMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReadMetaFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReadMetaFunc) History() []LSIFStoreReadMetaFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReadMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReadMetaFuncCall is an object that describes an invocation of
// method ReadMeta on an instance of MockLSIFStore.
type LSIFStoreReadMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.MetaData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReadMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReadMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreReadReferencesFunc describes the behavior when the
// ReadReferences method of the parent MockLSIFStore instance is invoked.
type LSIFStoreReadReferencesFunc struct {
	defaultHook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	hooks       []func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	history     []LSIFStoreReadReferencesFuncCall
	mutex       sync.Mutex
}

// ReadReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) ReadReferences(v0 context.Context, v1 int, v2 string, v3 string, v4 int, v5 int) ([]lsifstore.LocationData, int, error) {
	r0, r1, r2 := m.ReadReferencesFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.ReadReferencesFunc.appendCall(LSIFStoreReadReferencesFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadReferences
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreReadReferencesFunc) SetDefaultHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadReferences method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreReadReferencesFunc) PushHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreReadReferencesFunc) SetDefaultReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreReadReferencesFunc) PushReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreReadReferencesFunc) nextHook() func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReadReferencesFunc) appendCall(r0 LSIFStoreReadReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReadReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReadReferencesFunc) History() []LSIFStoreReadReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReadReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReadReferencesFuncCall is an object that describes an invocation
// of method ReadReferences on an instance of MockLSIFStore.
type LSIFStoreReadReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.LocationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReadReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReadReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreReadResultChunkFunc describes the behavior when the
// ReadResultChunk method of the parent MockLSIFStore instance is invoked.
type LSIFStoreReadResultChunkFunc struct {
	defaultHook func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)
	hooks       []func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)
	history     []LSIFStoreReadResultChunkFuncCall
	mutex       sync.Mutex
}

// ReadResultChunk delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) ReadResultChunk(v0 context.Context, v1 int, v2 int) (lsifstore.ResultChunkData, bool, error) {
	r0, r1, r2 := m.ReadResultChunkFunc.nextHook()(v0, v1, v2)
	m.ReadResultChunkFunc.appendCall(LSIFStoreReadResultChunkFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadResultChunk
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreReadResultChunkFunc) SetDefaultHook(hook func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadResultChunk method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreReadResultChunkFunc) PushHook(hook func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreReadResultChunkFunc) SetDefaultReturn(r0 lsifstore.ResultChunkData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreReadResultChunkFunc) PushReturn(r0 lsifstore.ResultChunkData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreReadResultChunkFunc) nextHook() func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReadResultChunkFunc) appendCall(r0 LSIFStoreReadResultChunkFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReadResultChunkFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReadResultChunkFunc) History() []LSIFStoreReadResultChunkFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReadResultChunkFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReadResultChunkFuncCall is an object that describes an
// invocation of method ReadResultChunk on an instance of MockLSIFStore.
type LSIFStoreReadResultChunkFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.ResultChunkData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReadResultChunkFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReadResultChunkFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreTransactFunc describes the behavior when the Transact method of
// the parent MockLSIFStore instance is invoked.
type LSIFStoreTransactFunc struct {
	defaultHook func(context.Context) (LSIFStore, error)
	hooks       []func(context.Context) (LSIFStore, error)
	history     []LSIFStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Transact(v0 context.Context) (LSIFStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(LSIFStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreTransactFunc) SetDefaultHook(hook func(context.Context) (LSIFStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreTransactFunc) PushHook(hook func(context.Context) (LSIFStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreTransactFunc) SetDefaultReturn(r0 LSIFStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreTransactFunc) PushReturn(r0 LSIFStore, r1 error) {
	f.PushHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

func (f *LSIFStoreTransactFunc) nextHook() func(context.Context) (LSIFStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreTransactFunc) appendCall(r0 LSIFStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreTransactFunc) History() []LSIFStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockLSIFStore.
type LSIFStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 LSIFStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteDefinitionsFunc describes the behavior when the
// WriteDefinitions method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDefinitionsFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.MonikerLocations) error
	hooks       []func(context.Context, int, chan lsifstore.MonikerLocations) error
	history     []LSIFStoreWriteDefinitionsFuncCall
	mutex       sync.Mutex
}

// WriteDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDefinitions(v0 context.Context, v1 int, v2 chan lsifstore.MonikerLocations) error {
	r0 := m.WriteDefinitionsFunc.nextHook()(v0, v1, v2)
	m.WriteDefinitionsFunc.appendCall(LSIFStoreWriteDefinitionsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDefinitions
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDefinitions method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDefinitionsFunc) PushHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDefinitionsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

func (f *LSIFStoreWriteDefinitionsFunc) nextHook() func(context.Context, int, chan lsifstore.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDefinitionsFunc) appendCall(r0 LSIFStoreWriteDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDefinitionsFunc) History() []LSIFStoreWriteDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDefinitionsFuncCall is an object that describes an
// invocation of method WriteDefinitions on an instance of MockLSIFStore.
type LSIFStoreWriteDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteDocumentsFunc describes the behavior when the
// WriteDocuments method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDocumentsFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.KeyedDocumentData) error
	hooks       []func(context.Context, int, chan lsifstore.KeyedDocumentData) error
	history     []LSIFStoreWriteDocumentsFuncCall
	mutex       sync.Mutex
}

// WriteDocuments delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocuments(v0 context.Context, v1 int, v2 chan lsifstore.KeyedDocumentData) error {
	r0 := m.WriteDocumentsFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentsFunc.appendCall(LSIFStoreWriteDocumentsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDocuments
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.KeyedDocumentData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocuments method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDocumentsFunc) PushHook(hook func(context.Context, int, chan lsifstore.KeyedDocumentData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
		return r0
	})
}

func (f *LSIFStoreWriteDocumentsFunc) nextHook() func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentsFunc) appendCall(r0 LSIFStoreWriteDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDocumentsFunc) History() []LSIFStoreWriteDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentsFuncCall is an object that describes an invocation
// of method WriteDocuments on an instance of MockLSIFStore.
type LSIFStoreWriteDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.KeyedDocumentData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteMetaFunc describes the behavior when the WriteMeta method
// of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteMetaFunc struct {
	defaultHook func(context.Context, int, lsifstore.MetaData) error
	hooks       []func(context.Context, int, lsifstore.MetaData) error
	history     []LSIFStoreWriteMetaFuncCall
	mutex       sync.Mutex
}

// WriteMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) WriteMeta(v0 context.Context, v1 int, v2 lsifstore.MetaData) error {
	r0 := m.WriteMetaFunc.nextHook()(v0, v1, v2)
	m.WriteMetaFunc.appendCall(LSIFStoreWriteMetaFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteMeta method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreWriteMetaFunc) SetDefaultHook(hook func(context.Context, int, lsifstore.MetaData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteMeta method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreWriteMetaFunc) PushHook(hook func(context.Context, int, lsifstore.MetaData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteMetaFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, lsifstore.MetaData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteMetaFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, lsifstore.MetaData) error {
		return r0
	})
}

func (f *LSIFStoreWriteMetaFunc) nextHook() func(context.Context, int, lsifstore.MetaData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteMetaFunc) appendCall(r0 LSIFStoreWriteMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteMetaFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteMetaFunc) History() []LSIFStoreWriteMetaFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteMetaFuncCall is an object that describes an invocation of
// method WriteMeta on an instance of MockLSIFStore.
type LSIFStoreWriteMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 lsifstore.MetaData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteReferencesFunc describes the behavior when the
// WriteReferences method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteReferencesFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.MonikerLocations) error
	hooks       []func(context.Context, int, chan lsifstore.MonikerLocations) error
	history     []LSIFStoreWriteReferencesFuncCall
	mutex       sync.Mutex
}

// WriteReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteReferences(v0 context.Context, v1 int, v2 chan lsifstore.MonikerLocations) error {
	r0 := m.WriteReferencesFunc.nextHook()(v0, v1, v2)
	m.WriteReferencesFunc.appendCall(LSIFStoreWriteReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteReferences
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteReferences method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteReferencesFunc) PushHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

func (f *LSIFStoreWriteReferencesFunc) nextHook() func(context.Context, int, chan lsifstore.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteReferencesFunc) appendCall(r0 LSIFStoreWriteReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteReferencesFunc) History() []LSIFStoreWriteReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteReferencesFuncCall is an object that describes an
// invocation of method WriteReferences on an instance of MockLSIFStore.
type LSIFStoreWriteReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteResultChunksFunc describes the behavior when the
// WriteResultChunks method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteResultChunksFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error
	hooks       []func(context.Context, int, chan lsifstore.IndexedResultChunkData) error
	history     []LSIFStoreWriteResultChunksFuncCall
	mutex       sync.Mutex
}

// WriteResultChunks delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteResultChunks(v0 context.Context, v1 int, v2 chan lsifstore.IndexedResultChunkData) error {
	r0 := m.WriteResultChunksFunc.nextHook()(v0, v1, v2)
	m.WriteResultChunksFunc.appendCall(LSIFStoreWriteResultChunksFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteResultChunks
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteResultChunks method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteResultChunksFunc) PushHook(hook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteResultChunksFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
		return r0
	})
}

func (f *LSIFStoreWriteResultChunksFunc) nextHook() func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteResultChunksFunc) appendCall(r0 LSIFStoreWriteResultChunksFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteResultChunksFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteResultChunksFunc) History() []LSIFStoreWriteResultChunksFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteResultChunksFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteResultChunksFuncCall is an object that describes an
// invocation of method WriteResultChunks on an instance of MockLSIFStore.
type LSIFStoreWriteResultChunksFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.IndexedResultChunkData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
